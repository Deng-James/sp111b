## Producer-consumer problem (生產者消費者問題)

生產者消費者問題（英語：Producer-consumer problem），也稱有限緩衝問題（Bounded-buffer problem），是一個多進程同步問題的經典案例。該問題描述了共享固定大小緩衝區的兩個進程——即所謂的「生產者」和「消費者」——在實際運行時會發生的問題。生產者的主要作用是生成一定量的數據放到緩衝區中，然後重複此過程。與此同時，消費者也在緩衝區消耗這些數據。該問題的關鍵就是要保證生產者不會在緩衝區滿時加入數據，消費者也不會在緩衝區中空時消耗數據。

要解決該問題，就必須讓生產者在緩衝區滿時休眠（要麼乾脆就放棄數據），等到下次消費者消耗緩衝區中的數據的時候，生產者才能被喚醒，開始往緩衝區添加數據。同樣，也可以讓消費者在緩衝區空時進入休眠，等到生產者往緩衝區添加數據之後，再喚醒消費者。通常採用進程間通信的方法解決該問題，常用的方法有信號燈法[1]等。如果解決方法不夠完善，則容易出現死鎖的情況。出現死鎖時，兩個執行緒都會陷入休眠，等待對方喚醒自己。該問題也能被推廣到多個生產者和消費者的情形。


- 使用信號燈的算法

信號燈可以避免上述喚醒指令不起作用的情況。該方法（見下面的代碼）使用了兩個信號燈，fillCount 和 emptyCount。fillCount 用於記錄緩衝區中將被讀取的數據項數（實際上就是有多少數據項在緩衝區里），emptyCount 用於記錄緩衝區中空閒空間數。當有新數據項被放入緩衝區時，fillCount 增加，emptyCount 減少。如果在生產者嘗試減少 emptyCount 的時候發現其值為零，那麼生產者就進入休眠。等到有數據項被消耗，emptyCount 增加的時候，生產者才被喚醒。消費者的行為類似。
> CODE
```
semaphore fillCount = 0; // 生产的项目
semaphore emptyCount = BUFFER_SIZE; // 剩余空间

procedure producer() {
    while (true) {
        item = produceItem();
        down(emptyCount);
            putItemIntoBuffer(item);
        up(fillCount);
    }
}

procedure consumer() {
    while (true) {
        down(fillCount);
            item = removeItemFromBuffer();
        up(emptyCount);
        consumeItem(item);
    }
}
```
## 哲學家就餐問題

哲學家就餐問題（英語：Dining philosophers problem）是在電腦科學中的一個經典問題，用來演示在並行計算中多執行緒同步（Synchronization）時產生的問題。

在1971年，著名的電腦科學家艾茲格·迪科斯徹提出了一個同步問題，即假設有五台電腦都試圖存取五份共享的磁帶驅動器。稍後，這個問題被托尼·霍爾重新表述為哲學家就餐問題。這個問題可以用來解釋死結和資源耗盡。

- 問題描述

哲學家就餐問題可以這樣表述，假設有五位哲學家圍坐在一張圓形餐桌旁，做以下兩件事情之一：吃飯，或者思考。吃東西的時候，他們就停止思考，思考的時候也停止吃東西。餐桌中間有一大碗義大利麵，每位哲學家之間各有一支餐叉。因為用一支餐叉很難吃到義大利麵，所以假設哲學家必須用兩支餐叉吃東西。他們只能使用自己左右手邊的那兩支餐叉。哲學家就餐問題有時也用米飯和五根筷子而不是義大利麵和餐叉來描述，因為吃米飯必須用兩根筷子。

這個問題不考慮義大利麵有多少，也不考慮哲學家的胃有多大。假設兩者都是無限大。

問題在於如何設計一套規則，使得在哲學家們在完全不交談，也就是無法知道其他人可能在什麼時候要吃飯或者思考的情況下，可以在這兩種狀態下永遠交替下去。

- 進一步說明
```
- 哲學家在左邊的叉子可用（沒有其他人拿起）之前處於思考狀態。如果左邊的叉子可用，就拿起來。
- 哲學家等待右邊的叉子可用。如果右邊的叉子可用，就拿起來。
- 如果兩個叉子都已經拿起來，開始吃義大利麵，每次吃麵都花費同樣的時間。
- 吃完後先放下左邊的叉子。
- 然後放下右邊的叉子。
- 開始思考（進入一個循環）
```
> 服務生解法

一個簡單的解法是引入一個餐廳服務生，哲學家必須經過他的允許才能拿起餐叉。因為服務生知道哪支餐叉正在使用，所以他能夠作出判斷避免死結。

為了演示這種解法，假設哲學家依次標號為A至E。如果A和C在吃東西，則有四支餐叉在使用中。B坐在A和C之間，所以兩支餐叉都無法使用，而D和E之間有一隻空餘的餐叉。假設這時D想要吃東西。如果他拿起了第五支餐叉，就有可能發生死結。相反，如果他徵求服務生同意，服務生會讓他等待。這樣，我們就能保證下次當兩把餐叉空餘出來時，一定有一位哲學家可以成功的得到一對餐叉，從而避免了死結。

> 資源分級解法


另一個簡單的解法是為資源（這裡是餐叉）分配一個偏序或者分級的關係，並約定所有資源都按照這種順序取得，按相反順序釋放，而且保證不會有兩個無關資源同時被同一項工作所需要。在哲學家就餐問題中，資源（餐叉）按照某種規則編號為1至5，每一個工作單元（哲學家）總是先拿起左右兩邊編號較低的餐叉，再拿編號較高的。用完餐叉後，他總是先放下編號較高的餐叉，再放下編號較低的。在這種情況下，當四位哲學家同時拿起他們手邊編號較低的餐叉時，只有編號最高的餐叉留在桌上，從而第五位哲學家就不能使用任何一支餐叉了。而且，只有一位哲學家能使用最高編號的餐叉，所以他能使用兩支餐叉用餐。當他吃完後，他會先放下編號最高的餐叉，再放下編號較低的餐叉，從而讓另一位哲學家拿起後邊的這隻開始吃東西。

儘管資源分級能避免死結，但這種策略並不總是實用的，特別是當所需資源的列表並不是事先知道的時候。例如，假設一個工作單元拿著資源3和5，並決定需要資源2，則必須先要釋放5，之後釋放3，才能得到2，之後必須重新按順序取得3和5。對需要存取大量資料庫記錄的電腦程式來說，如果需要先釋放高編號的記錄才能存取新的記錄，那麼執行效率就不會高，因此這種方法在這裡並不實用。


### 參考資料 
[https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98](https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98)
[https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98](https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98)
